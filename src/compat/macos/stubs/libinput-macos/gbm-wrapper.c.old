/*
 * macOS/iOS GBM wrapper implementation using IOSurface/Metal
 * Maps GBM API to Apple's IOSurface for buffer management
 * 
 * This provides a complete GBM implementation for macOS/iOS by wrapping
 * IOSurface APIs, allowing Linux graphics code (Mesa, Wayland) to work
 * on Apple platforms.
 */

#ifdef __APPLE__

#include "gbm.h"
#include "../../../../metal_dmabuf.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>

// iOS compatibility: Import IOSurface correctly for iOS
#if TARGET_OS_IPHONE || TARGET_OS_SIMULATOR
#include <IOSurface/IOSurfaceRef.h>
#else
#include <IOSurface/IOSurface.h>
#endif
#include <CoreVideo/CoreVideo.h>

// Internal GBM device structure
struct gbm_device {
    int fd;  // Not used on macOS, but kept for compatibility
    void *user_data;
};

// Internal GBM buffer object structure
struct gbm_bo {
    struct gbm_device *gbm;           // Back reference to device
    struct metal_dmabuf_buffer *metal_buffer;
    uint32_t width;
    uint32_t height;
    uint32_t format;                  // GBM format (fourcc code)
    uint32_t stride;
    uint64_t modifier;                 // Linux concept, always 0 on macOS
    int fd;                           // Mock FD for IPC (socketpair)
    int plane_count;                   // Always 1 on macOS (single plane)
    union gbm_bo_handle handle;        // Stores IOSurfaceRef pointer
    uint32_t iosurface_id;            // Global IOSurface ID for cross-process sharing
    void *user_data;                  // For application use
};

// Convert GBM format to Metal/IOSurface format
static uint32_t gbm_to_iosurface_format(uint32_t gbm_format) {
    switch (gbm_format) {
        case GBM_BO_FORMAT_XRGB8888:
        case GBM_BO_FORMAT_ARGB8888:
            return kCVPixelFormatType_32BGRA;
        default:
            return kCVPixelFormatType_32BGRA;
    }
}

// Convert GBM format enum to format value
static uint32_t gbm_format_to_value(uint32_t gbm_format) {
    // On Linux, these map to DRM fourcc codes
    // For macOS, we'll use simple values
    switch (gbm_format) {
        case GBM_BO_FORMAT_XRGB8888:
            return 0x34325258; // 'XR24' equivalent
        case GBM_BO_FORMAT_ARGB8888:
            return 0x34325241; // 'AR24' equivalent
        default:
            return 0x34325258; // Default to XRGB8888
    }
}

struct gbm_device *gbm_create_device(int fd) {
    struct gbm_device *gbm = calloc(1, sizeof(*gbm));
    if (!gbm) return NULL;
    
    gbm->fd = fd;  // Store but don't use on macOS
    return gbm;
}

void gbm_device_destroy(struct gbm_device *gbm) {
    if (gbm) {
        free(gbm);
    }
}

int gbm_device_get_fd(struct gbm_device *gbm) {
    if (!gbm) return -1;
    return gbm->fd;
}

struct gbm_bo *gbm_bo_create(struct gbm_device *gbm,
                              uint32_t width, uint32_t height,
                              uint32_t format, uint32_t flags) {
    if (!gbm || width == 0 || height == 0) return NULL;
    
    struct gbm_bo *bo = calloc(1, sizeof(*bo));
    if (!bo) return NULL;
    
    uint32_t iosurface_format = gbm_to_iosurface_format(format);
    bo->metal_buffer = metal_dmabuf_create_buffer(width, height, iosurface_format);
    if (!bo->metal_buffer) {
        free(bo);
        return NULL;
    }
    
    bo->width = width;
    bo->height = height;
    bo->format = gbm_format_to_value(format);
    bo->stride = bo->metal_buffer->stride;
    bo->modifier = 0;  // No modifiers on macOS
    bo->plane_count = 1;
    bo->fd = metal_dmabuf_get_fd(bo->metal_buffer);
    bo->gbm = gbm;
    
    // Store IOSurface pointer in handle
    bo->handle.ptr = (void *)bo->metal_buffer->iosurface;
    
    // Get IOSurface ID for cross-process sharing
    if (bo->metal_buffer->iosurface) {
        bo->iosurface_id = IOSurfaceGetID(bo->metal_buffer->iosurface);
    }
    
    return bo;
}

struct gbm_bo *gbm_bo_create_with_modifiers(struct gbm_device *gbm,
                                             uint32_t width, uint32_t height,
                                             uint32_t format,
                                             const uint64_t *modifiers,
                                             const unsigned int count) {
    // Ignore modifiers on macOS - just create standard buffer
    (void)modifiers;
    (void)count;
    return gbm_bo_create(gbm, width, height, format, GBM_BO_USE_RENDERING);
}

struct gbm_bo *gbm_bo_create_with_modifiers2(struct gbm_device *gbm,
                                              uint32_t width, uint32_t height,
                                              uint32_t format,
                                              const uint64_t *modifiers,
                                              const unsigned int count,
                                              uint32_t flags) {
    // Ignore modifiers on macOS - just create standard buffer
    (void)modifiers;
    (void)count;
    return gbm_bo_create(gbm, width, height, format, flags);
}

void gbm_bo_destroy(struct gbm_bo *bo) {
    if (!bo) return;
    
    if (bo->metal_buffer) {
        metal_dmabuf_destroy_buffer(bo->metal_buffer);
        bo->metal_buffer = NULL;
    }
    
    free(bo);
}

uint32_t gbm_bo_get_width(struct gbm_bo *bo) {
    if (!bo) return 0;
    return bo->width;
}

uint32_t gbm_bo_get_height(struct gbm_bo *bo) {
    if (!bo) return 0;
    return bo->height;
}

uint32_t gbm_bo_get_stride(struct gbm_bo *bo) {
    if (!bo || !bo->metal_buffer) return 0;
    return bo->stride;
}

uint32_t gbm_bo_get_stride_for_plane(struct gbm_bo *bo, int plane) {
    if (!bo || plane != 0) return 0;
    return gbm_bo_get_stride(bo);
}

uint32_t gbm_bo_get_offset(struct gbm_bo *bo, int plane) {
    if (!bo || plane != 0) return 0;
    return 0;  // Single plane, no offset
}

uint64_t gbm_bo_get_modifier(struct gbm_bo *bo) {
    if (!bo) return 0;
    return bo->modifier;
}

int gbm_bo_get_fd(struct gbm_bo *bo) {
    if (!bo) return -1;
    return bo->fd;
}

int gbm_bo_get_plane_count(struct gbm_bo *bo) {
    if (!bo) return 0;
    return bo->plane_count;
}

union gbm_bo_handle gbm_bo_get_handle(struct gbm_bo *bo) {
    union gbm_bo_handle handle = {0};
    if (bo) {
        handle = bo->handle;
    }
    return handle;
}

uint32_t gbm_bo_get_format(struct gbm_bo *bo) {
    if (!bo) return 0;
    return bo->format;
}

// Additional GBM functions that may be needed

// Get user data pointer
void *gbm_bo_get_user_data(struct gbm_bo *bo) {
    if (!bo) return NULL;
    return bo->user_data;
}

// Set user data pointer
void gbm_bo_set_user_data(struct gbm_bo *bo, void *data) {
    if (bo) {
        bo->user_data = data;
    }
}

// Get the device that created this buffer
struct gbm_device *gbm_bo_get_device(struct gbm_bo *bo) {
    if (!bo) return NULL;
    return bo->gbm;
}

// Get IOSurfaceRef from gbm_bo (macOS/iOS specific helper)
#ifdef __OBJC__
IOSurfaceRef gbm_bo_get_iosurface(struct gbm_bo *bo) {
    if (!bo || !bo->metal_buffer) return NULL;
    return bo->metal_buffer->iosurface;
}
#else
// C-only version - returns void* that can be cast to IOSurfaceRef
void *gbm_bo_get_iosurface(struct gbm_bo *bo) {
    if (!bo || !bo->metal_buffer) return NULL;
    return (void *)bo->metal_buffer->iosurface;
}
#endif

// Get IOSurface ID (for cross-process sharing)
uint32_t gbm_bo_get_iosurface_id(struct gbm_bo *bo) {
    if (!bo) return 0;
    return bo->iosurface_id;
}

// Map buffer for CPU access (read/write)
void *gbm_bo_map(struct gbm_bo *bo, uint32_t x, uint32_t y, uint32_t width, uint32_t height,
                 uint32_t flags, uint32_t *stride, void **map_data) {
    if (!bo || !bo->metal_buffer || !bo->metal_buffer->iosurface) {
        if (stride) *stride = 0;
        if (map_data) *map_data = NULL;
        return NULL;
    }
    
    IOSurfaceRef iosurface = bo->metal_buffer->iosurface;
    
    // Lock IOSurface for CPU access
    IOReturn ret = IOSurfaceLock(iosurface, kIOSurfaceLockReadWrite, NULL);
    if (ret != kIOReturnSuccess) {
        if (stride) *stride = 0;
        if (map_data) *map_data = NULL;
        return NULL;
    }
    
    void *base = IOSurfaceGetBaseAddress(iosurface);
    uint32_t surface_stride = IOSurfaceGetBytesPerRow(iosurface);
    
    if (stride) *stride = surface_stride;
    if (map_data) *map_data = bo;  // Store bo pointer for unmapping
    
    // Calculate offset for x,y (assuming 4 bytes per pixel)
    void *ptr = (char *)base + (y * surface_stride) + (x * 4);
    
    (void)width;   // Unused but kept for API compatibility
    (void)height;  // Unused but kept for API compatibility
    (void)flags;   // Unused but kept for API compatibility
    
    return ptr;
}

// Unmap buffer after CPU access
void gbm_bo_unmap(struct gbm_bo *bo, void *map_data) {
    if (!bo || !bo->metal_buffer || !bo->metal_buffer->iosurface) return;
    if (map_data != bo) return;  // Sanity check
    
    IOSurfaceRef iosurface = bo->metal_buffer->iosurface;
    IOSurfaceUnlock(iosurface, kIOSurfaceLockReadWrite, NULL);
}

#endif // __APPLE__

